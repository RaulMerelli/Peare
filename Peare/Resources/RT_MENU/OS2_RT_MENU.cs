
using System;
using System.Text;
using System.IO;
using System.Collections.Generic;

namespace Peare
{
    public class OS2_RTMENU
    {
        // The RT_MENU in OS/2 is very different from the equivalent for Windows.
        // Special thanks to EDM2.com for providing how this resource is structured.
        // The format is described at "when rt = 3" (search for it in the page)
        // https://www.edm2.com/index.php/Resources_and_Decompiling_Them
        // This class has been almost completely generated by Google Gemini after providing the described format and structure.

        // Constants for Menu Item Styles (MIS_*) - These are illustrative, actual values might vary slightly
        // These values are common in Windows resource definitions.
        private const ushort MIS_STRING = 0x0000;       // Default for a simple string menu item
        private const ushort MIS_SUBMENU = 0x0010;      // Indicates a submenu (POPUP)
        private const ushort MIS_SEPARATOR = 0x0800;    // Separator line
        private const ushort MIS_BITMAP = 0x0004;       // Item displays a bitmap
                                                        // You can add more MIS_* constants here if needed for other styles.

        // Constants for Menu Item Attributes (MIA_*) - Illustrative
        // These values are common in Windows resource definitions.
        private const ushort MIA_ENABLED = 0x0000;      // Item is enabled (default)
        private const ushort MIA_GRAYED = 0x0001;       // Item is grayed (disabled visually)
        private const ushort MIA_DISABLED = 0x0002;     // Item is disabled (cannot be selected)
        private const ushort MIA_CHECKED = 0x0008;      // Item has a checkmark
                                                        // You can add more MIA_* constants here if needed for other attributes.

        // Constants for Accelerator Key Types (ACCEL_*)
        // These values are common in Windows resource definitions.
        private const ushort ACCEL_VIRTUALKEY = 0x0001;
        private const ushort ACCEL_NOINVERT = 0x0002;
        private const ushort ACCEL_SHIFT = 0x0004;
        private const ushort ACCEL_CONTROL = 0x0008;
        private const ushort ACCEL_ALT = 0x0010;

        private static byte ReadByte(byte[] data, ref int offset)
        {
            if (offset + 1 > data.Length)
            {
                throw new EndOfStreamException("Attempted to read past end of data.");
            }
            return data[offset++];
        }

        private static ushort ReadUInt16(byte[] data, ref int offset)
        {
            if (offset + 2 > data.Length)
            {
                throw new EndOfStreamException("Attempted to read past end of data for ushort.");
            }
            ushort value = BitConverter.ToUInt16(data, offset);
            offset += 2;
            return value;
        }

        private static string GetRcKeyString(ushort key)
        {
            // Common virtual key codes mapping to RC file constants
            switch (key)
            {
                case 0x70: return "VK_F1";
                case 0x71: return "VK_F2";
                case 0x72: return "VK_F3";
                case 0x73: return "VK_F4";
                case 0x74: return "VK_F5";
                case 0x75: return "VK_F6";
                case 0x76: return "VK_F7";
                case 0x77: return "VK_F8";
                case 0x78: return "VK_F9";
                case 0x79: return "VK_F10";
                case 0x7A: return "VK_F11";
                case 0x7B: return "VK_F12";
                case 0x25: return "VK_LEFT";
                case 0x26: return "VK_UP";
                case 0x27: return "VK_RIGHT";
                case 0x28: return "VK_DOWN";
                case 0x0D: return "VK_RETURN";
                case 0x1B: return "VK_ESCAPE";
                case 0x20: return "VK_SPACE";
                case 0x09: return "VK_TAB";
                case 0x08: return "VK_BACK";
                case 0x2E: return "VK_DELETE";
                case 0x2D: return "VK_INSERT";
                case 0x21: return "VK_PRIOR"; // Page Up
                case 0x22: return "VK_NEXT";  // Page Down
                case 0x23: return "VK_END";
                case 0x24: return "VK_HOME";
                // Add more virtual key mappings as needed

                default:
                    // Handle printable ASCII characters (e.g., 'A', 'B', '1', '2')
                    if (key >= 0x20 && key <= 0x7E) // ASCII printable range
                    {
                        return $"\"{Convert.ToChar(key)}\"";
                    }
                    // Fallback for unknown or non-printable keys, represent as hex
                    return $"0x{key:X4}";
            }
        }

        private static string GetRcAccelTypeString(ushort type)
        {
            List<string> flags = new List<string>();
            if ((type & ACCEL_VIRTUALKEY) != 0) flags.Add("VIRTUALKEY");
            if ((type & ACCEL_NOINVERT) != 0) flags.Add("NOINVERT");
            if ((type & ACCEL_SHIFT) != 0) flags.Add("SHIFT");
            if ((type & ACCEL_CONTROL) != 0) flags.Add("CONTROL");
            if ((type & ACCEL_ALT) != 0) flags.Add("ALT");

            // If no known flags are set, it might be a direct character accelerator without flags,
            // or an unknown type.
            if (flags.Count == 0) return "NO_FLAGS"; // Or throw an error if strict validation needed
            return string.Join(" | ", flags);
        }

        private static void ParseMenu(byte[] data, ref int offset, StringBuilder sb, int indentLevel, bool isSubMenu = false)
        {
            string indent = new string(' ', indentLevel * 4);

            // Menu Header fields
            ushort db = ReadUInt16(data, ref offset);    // 16 1 db
            ushort type = ReadUInt16(data, ref offset);  // 16 1 type (0 or 1)
            ushort cp = ReadUInt16(data, ref offset);    // 16 1 cp (codepage, e.g., 850)
            ushort offs = ReadUInt16(data, ref offset);  // 16 1 offs (starting offset of menu data from start of structure)
            ushort count = ReadUInt16(data, ref offset); // 16 1 count (number of items)

            // If the menu type is 1, count is followed by another 16-bit field, ppoffs.
            // As per the prompt, we won't handle type 1 menus fully, so we just consume the ppoffs field.
            if (type == 1)
            {
                ReadUInt16(data, ref offset); // ppoffs (presentation parameter offset)
            }

            // Emit the RC file syntax for the menu or popup block
            if (isSubMenu)
            {
                // For submenus, the 'POPUP "Text"' part is handled by the parent item.
                sb.AppendLine($"{indent}{{");
            }
            else
            {
                sb.AppendLine($"MENU");
                sb.AppendLine($"{indent}{{");
            }

            // Parse each menu item
            for (int i = 0; i < count; i++)
            {
                string itemIndent = new string(' ', (indentLevel + 1) * 4);
                ushort style = ReadUInt16(data, ref offset);  // 16 1 style (MIS_*)
                ushort attrib = ReadUInt16(data, ref offset); // 16 1 attrib (MIA_*)
                ushort id = ReadUInt16(data, ref offset);     // 16 1 Id (item identifier)

                // Handle optional data based on the item's style
                if ((style & MIS_SUBMENU) != 0) // Check if it's a submenu
                {
                    // Data is a menu structure, read the submenu's text first
                    string popupText = RT_STRING.ReadNullTerminatedString(data, ref offset, cp);
                    sb.AppendLine($"{itemIndent}POPUP \"{popupText}\"");
                    // Recursively call ParseMenu for the submenu's content
                    ParseMenu(data, ref offset, sb, indentLevel + 1, true);
                }
                else if ((style & MIS_SEPARATOR) != 0 || id == 65535) // Check if it's a separator
                {
                    sb.AppendLine($"{itemIndent}MENUITEM SEPARATOR");
                }
                else if ((style & MIS_BITMAP) != 0) // Check if it's a bitmap item
                {
                    byte bitmapType = ReadByte(data, ref offset);
                    string bitmapId = "";
                    if (bitmapType == 0xFF) // 'FF'x, followed by a 16-bit word (resource identifier)
                    {
                        ushort resourceId = ReadUInt16(data, ref offset);
                        bitmapId = $"{resourceId}";
                    }
                    else if (bitmapType == 0x00) // '00'x, no resource identifier provided
                    {
                        bitmapId = "0"; // RC typically uses 0 or omits the ID for no resource
                    }
                    else if (bitmapType == '#') // '#', and subsequent characters make up the decimal representation
                    {
                        int start = offset; // Start reading digits from current offset
                        while (offset < data.Length && data[offset] >= '0' && data[offset] <= '9')
                        {
                            offset++;
                        }
                        if (offset > start)
                        {
                            bitmapId = Encoding.ASCII.GetString(data, start, offset - start);
                        }
                        else
                        {
                            bitmapId = "INVALID_BITMAP_ID"; // No digits found after '#'
                        }
                    }
                    else
                    {
                        // Unknown bitmap data format, treat as an error or consume the byte
                        bitmapId = "UNKNOWN_BITMAP_FORMAT";
                    }
                    // RC syntax for bitmap menu item might vary; this is a common form.
                    sb.Append($"{itemIndent}MENUITEM \"\", {id}, MIS_BITMAP");
                    if (!string.IsNullOrEmpty(bitmapId) && bitmapId != "0") sb.Append($", {bitmapId}");
                    // Apply attributes
                    if ((attrib & MIA_GRAYED) != 0) sb.Append(", GRAYED");
                    if ((attrib & MIA_DISABLED) != 0) sb.Append(", DISABLED");
                    if ((attrib & MIA_CHECKED) != 0) sb.Append(", CHECKED");
                    sb.AppendLine();
                }
                else // Default case: MIS_STRING or other simple menu item
                {
                    // Data is a null-terminated string for the menu item text
                    string itemText = RT_STRING.ReadNullTerminatedString(data, ref offset, cp);
                    sb.Append($"{itemIndent}MENUITEM \"{itemText}\", {id}");
                    // Apply attributes
                    if ((attrib & MIA_GRAYED) != 0) sb.Append(", GRAYED");
                    if ((attrib & MIA_DISABLED) != 0) sb.Append(", DISABLED");
                    if ((attrib & MIA_CHECKED) != 0) sb.Append(", CHECKED");
                    sb.AppendLine();
                }
            }
            sb.AppendLine($"{indent}}}"); // End of current menu/popup block
        }

        private static string ParseAccelTable(byte[] data)
        {
            StringBuilder sb = new StringBuilder();
            int offset = 0;
            try
            {
                // AccelTable data starts with a 16-bit count and a 16-bit codepage.
                ushort count = ReadUInt16(data, ref offset); // 16 1 count (number of keys)
                ushort cp = ReadUInt16(data, ref offset);    // 16 1 cp (acceltable codepage)

                // Emit the RC file syntax for the accelerator table.
                // A placeholder ID is used as the prompt doesn't specify one.
                sb.AppendLine("ACCELERATORS ID_ACCEL_TABLE"); // Example: ID_ACCEL_TABLE
                sb.AppendLine("{");

                // Iterate through each accel-key triplet (type, key, cmd)
                for (int i = 0; i < count; i++)
                {
                    ushort type = ReadUInt16(data, ref offset); // 16 1 type (key's type: VIRTUALKEY, shifted, etc.)
                    ushort key = ReadUInt16(data, ref offset);  // 16 1 key (key's value: VK_F1, "a", etc.)
                    ushort cmd = ReadUInt16(data, ref offset);  // 16 1 cmd (accel command)

                    // Convert key and type values to their RC file string representations
                    string rcKey = GetRcKeyString(key);
                    string rcType = GetRcAccelTypeString(type);

                    // Append the accelerator entry to the RC output
                    sb.AppendLine($"    {rcKey}, {cmd}, {rcType}");
                }
                sb.AppendLine("}");
                return sb.ToString();
            }
            catch (EndOfStreamException)
            {
                // Parsing failed due to insufficient data.
                return null;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error parsing accel table: {ex.Message}");
                return null;
            }
        }

        public static string Get(byte[] data, ModuleResources.ModuleProperties properties)
        {
            if (data == null || data.Length == 0)
            {
                return "// Error: Input data is null or empty.";
            }

            // --- Attempt to parse as a Menu resource ---
            try
            {
                // A menu structure should be at least 10 bytes long (5 ushorts: db, type, cp, offs, count).
                if (data.Length >= 10)
                {
                    // Peek at the initial bytes to make a heuristic guess without modifying the offset.
                    ushort db = BitConverter.ToUInt16(data, 0);
                    ushort type = BitConverter.ToUInt16(data, 2);
                    ushort cp = BitConverter.ToUInt16(data, 4);
                    ushort offs = BitConverter.ToUInt16(data, 6);
                    ushort count = BitConverter.ToUInt16(data, 8);

                    // Basic heuristic for a menu:
                    // - Menu type (0 or 1) is valid.
                    // - Offset to data should be within bounds.
                    // - Item count should not be excessively large (e.g., > 1000 is unlikely for a single menu).
                    // - 'db' is often 0 for menus.
                    if ((type == 0 || type == 1) && offs < data.Length && count < 1000)
                    {
                        StringBuilder sb = new StringBuilder();
                        int menuOffset = 0; // Start a fresh offset for the actual parsing function
                        ParseMenu(data, ref menuOffset, sb, 0);
                        return sb.ToString();
                    }
                }
            }
            catch (EndOfStreamException)
            {
                // This indicates that the data was too short or malformed for a menu.
                // Continue to try other types.
            }
            catch (Exception ex)
            {
                // Log any other unexpected errors during menu parsing attempt
                Console.WriteLine($"Menu parsing attempt failed: {ex.Message}");
            }

            // --- Attempt to parse as a StringTable resource ---
            try
            {
                // A string table should be at least 3 bytes long (2-byte dummy + 1-byte len).
                if (data.Length >= 3)
                {
                    string result = RT_STRING.Get(data, properties);
                    if (result != null) return result; // If parsing was successful, return the result
                }
            }
            catch (EndOfStreamException) { /* Continue to try other types */ }
            catch (Exception ex)
            {
                Console.WriteLine($"StringTable parsing attempt failed: {ex.Message}");
            }

            // --- Attempt to parse as an AccelTable resource ---
            try
            {
                // An accel table should be at least 6 bytes long (count, cp, type1 each 2 bytes).
                if (data.Length >= 6)
                {
                    // Peek at the initial bytes.
                    ushort count = BitConverter.ToUInt16(data, 0);
                    ushort cp = BitConverter.ToUInt16(data, 2);
                    ushort type1 = BitConverter.ToUInt16(data, 4);

                    // Heuristic for an accel table:
                    // - 'count' should be a reasonable number of accelerators (e.g., < 1000).
                    // - 'type1' should be a combination of known accelerator type flags (or 0 if no flags).
                    if (count < 1000 && (type1 == 0 || (type1 & (ACCEL_VIRTUALKEY | ACCEL_NOINVERT | ACCEL_SHIFT | ACCEL_CONTROL | ACCEL_ALT)) != 0))
                    {
                        string result = ParseAccelTable(data);
                        if (result != null) return result; // If parsing was successful, return the result
                    }
                }
            }
            catch (EndOfStreamException) { /* Continue to try other types */ }
            catch (Exception ex)
            {
                Console.WriteLine($"AccelTable parsing attempt failed: {ex.Message}");
            }

            // If none of the parsing attempts succeeded, return an error message.
            return "// Error: Could not determine resource type or parse data.";
        }
    }

}
