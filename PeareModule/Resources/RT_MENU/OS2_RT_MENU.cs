
using System;
using System.Text;
using System.IO;
using System.Collections.Generic;

namespace PeareModule
{
    public class OS2_RTMENU
    {
        // The RT_MENU in OS/2 is very different from the equivalent for Windows.
        // Special thanks to EDM2.com for providing how this resource is structured.
        // The format is described at "when rt = 3" (search for it in the page)
        // https://www.edm2.com/index.php/Resources_and_Decompiling_Them
        // This class has been almost completely generated by Google Gemini after providing the described format and structure.

        // Constants for Menu Item Styles (MIS_*) - These are illustrative, actual values might vary slightly
        // These values are common in Windows resource definitions.
        private const ushort MIS_STRING = 0x0000;       // Default for a simple string menu item
        private const ushort MIS_SUBMENU = 0x0010;      // Indicates a submenu (POPUP)
        private const ushort MIS_SEPARATOR = 0x0800;    // Separator line
        private const ushort MIS_BITMAP = 0x0004;       // Item displays a bitmap
                                                        // You can add more MIS_* constants here if needed for other styles.

        // Constants for Menu Item Attributes (MIA_*) - Illustrative
        // These values are common in Windows resource definitions.
        private const ushort MIA_ENABLED = 0x0000;      // Item is enabled (default)
        private const ushort MIA_GRAYED = 0x0001;       // Item is grayed (disabled visually)
        private const ushort MIA_DISABLED = 0x0002;     // Item is disabled (cannot be selected)
        private const ushort MIA_CHECKED = 0x0008;      // Item has a checkmark
                                                        // You can add more MIA_* constants here if needed for other attributes.

        private static byte ReadByte(byte[] data, ref int offset)
        {
            if (offset + 1 > data.Length)
            {
                throw new EndOfStreamException("Attempted to read past end of data.");
            }
            return data[offset++];
        }

        private static ushort ReadUInt16(byte[] data, ref int offset)
        {
            if (offset + 2 > data.Length)
            {
                throw new EndOfStreamException("Attempted to read past end of data for ushort.");
            }
            ushort value = BitConverter.ToUInt16(data, offset);
            offset += 2;
            return value;
        }

        private static void ParseMenu(byte[] data, ref int offset, StringBuilder sb, int indentLevel, bool isSubMenu = false)
        {
            string indent = new string(' ', indentLevel * 4);

            // Menu Header fields
            ushort db = ReadUInt16(data, ref offset);    // 16 1 db
            ushort type = ReadUInt16(data, ref offset);  // 16 1 type (0 or 1)
            ushort cp = ReadUInt16(data, ref offset);    // 16 1 cp (codepage, e.g., 850)
            ushort offs = ReadUInt16(data, ref offset);  // 16 1 offs (starting offset of menu data from start of structure)
            ushort count = ReadUInt16(data, ref offset); // 16 1 count (number of items)

            // If the menu type is 1, count is followed by another 16-bit field, ppoffs.
            // As per the prompt, we won't handle type 1 menus fully, so we just consume the ppoffs field.
            if (type == 1)
            {
                ReadUInt16(data, ref offset); // ppoffs (presentation parameter offset)
            }

            // Emit the RC file syntax for the menu or popup block
            if (isSubMenu)
            {
                // For submenus, the 'POPUP "Text"' part is handled by the parent item.
                sb.AppendLine($"{indent}{{");
            }
            else
            {
                sb.AppendLine($"MENU");
                sb.AppendLine($"{indent}{{");
            }

            // Parse each menu item
            for (int i = 0; i < count; i++)
            {
                string itemIndent = new string(' ', (indentLevel + 1) * 4);
                ushort style = ReadUInt16(data, ref offset);  // 16 1 style (MIS_*)
                ushort attrib = ReadUInt16(data, ref offset); // 16 1 attrib (MIA_*)
                ushort id = ReadUInt16(data, ref offset);     // 16 1 Id (item identifier)

                // Handle optional data based on the item's style
                if ((style & MIS_SUBMENU) != 0) // Check if it's a submenu
                {
                    // Data is a menu structure, read the submenu's text first
                    string popupText = RT_STRING.ReadNullTerminatedString(data, ref offset, cp);
                    sb.AppendLine($"{itemIndent}POPUP \"{popupText}\"");
                    // Recursively call ParseMenu for the submenu's content
                    ParseMenu(data, ref offset, sb, indentLevel + 1, true);
                }
                else if ((style & MIS_SEPARATOR) != 0 || id == 65535) // Check if it's a separator
                {
                    sb.AppendLine($"{itemIndent}MENUITEM SEPARATOR");
                }
                else if ((style & MIS_BITMAP) != 0) // Check if it's a bitmap item
                {
                    byte bitmapType = ReadByte(data, ref offset);
                    string bitmapId = "";
                    if (bitmapType == 0xFF) // 'FF'x, followed by a 16-bit word (resource identifier)
                    {
                        ushort resourceId = ReadUInt16(data, ref offset);
                        bitmapId = $"{resourceId}";
                    }
                    else if (bitmapType == 0x00) // '00'x, no resource identifier provided
                    {
                        bitmapId = "0"; // RC typically uses 0 or omits the ID for no resource
                    }
                    else if (bitmapType == '#') // '#', and subsequent characters make up the decimal representation
                    {
                        int start = offset; // Start reading digits from current offset
                        while (offset < data.Length && data[offset] >= '0' && data[offset] <= '9')
                        {
                            offset++;
                        }
                        if (offset > start)
                        {
                            bitmapId = Encoding.ASCII.GetString(data, start, offset - start);
                        }
                        else
                        {
                            bitmapId = "INVALID_BITMAP_ID"; // No digits found after '#'
                        }
                    }
                    else
                    {
                        // Unknown bitmap data format, treat as an error or consume the byte
                        bitmapId = "UNKNOWN_BITMAP_FORMAT";
                    }
                    // RC syntax for bitmap menu item might vary; this is a common form.
                    sb.Append($"{itemIndent}MENUITEM \"\", {id}, MIS_BITMAP");
                    if (!string.IsNullOrEmpty(bitmapId) && bitmapId != "0") sb.Append($", {bitmapId}");
                    // Apply attributes
                    if ((attrib & MIA_GRAYED) != 0) sb.Append(", GRAYED");
                    if ((attrib & MIA_DISABLED) != 0) sb.Append(", DISABLED");
                    if ((attrib & MIA_CHECKED) != 0) sb.Append(", CHECKED");
                    sb.AppendLine();
                }
                else // Default case: MIS_STRING or other simple menu item
                {
                    // Data is a null-terminated string for the menu item text
                    string itemText = RT_STRING.ReadNullTerminatedString(data, ref offset, cp);
                    sb.Append($"{itemIndent}MENUITEM \"{itemText}\", {id}");
                    // Apply attributes
                    if ((attrib & MIA_GRAYED) != 0) sb.Append(", GRAYED");
                    if ((attrib & MIA_DISABLED) != 0) sb.Append(", DISABLED");
                    if ((attrib & MIA_CHECKED) != 0) sb.Append(", CHECKED");
                    sb.AppendLine();
                }
            }
            sb.AppendLine($"{indent}}}"); // End of current menu/popup block
        }

        public static string Get(byte[] data, ModuleResources.ModuleProperties properties)
        {
            if (data == null || data.Length == 0)
            {
                return "// Error: Input data is null or empty.";
            }

            // --- Attempt to parse as a Menu resource ---
            try
            {
                // A menu structure should be at least 10 bytes long (5 ushorts: db, type, cp, offs, count).
                if (data.Length >= 10)
                {
                    // Peek at the initial bytes to make a heuristic guess without modifying the offset.
                    ushort db = BitConverter.ToUInt16(data, 0);
                    ushort type = BitConverter.ToUInt16(data, 2);
                    ushort cp = BitConverter.ToUInt16(data, 4);
                    ushort offs = BitConverter.ToUInt16(data, 6);
                    ushort count = BitConverter.ToUInt16(data, 8);

                    // Basic heuristic for a menu:
                    // - Menu type (0 or 1) is valid.
                    // - Offset to data should be within bounds.
                    // - Item count should not be excessively large (e.g., > 1000 is unlikely for a single menu).
                    // - 'db' is often 0 for menus.
                    if ((type == 0 || type == 1) && offs < data.Length && count < 1000)
                    {
                        StringBuilder sb = new StringBuilder();
                        int menuOffset = 0; // Start a fresh offset for the actual parsing function
                        ParseMenu(data, ref menuOffset, sb, 0);
                        return sb.ToString();
                    }
                }
            }
            catch (EndOfStreamException)
            {
                // This indicates that the data was too short or malformed for a menu.
                // Continue to try other types.
            }
            catch (Exception ex)
            {
                // Log any other unexpected errors during menu parsing attempt
                Console.WriteLine($"Menu parsing attempt failed: {ex.Message}");
            }

            // --- Attempt to parse as a StringTable resource ---
            try
            {
                // A string table should be at least 3 bytes long (2-byte dummy + 1-byte len).
                if (data.Length >= 3)
                {
                    string result = RT_STRING.Get(data, properties);
                    if (result != null) return result; // If parsing was successful, return the result
                }
            }
            catch (EndOfStreamException) { /* Continue to try other types */ }
            catch (Exception ex)
            {
                Console.WriteLine($"StringTable parsing attempt failed: {ex.Message}");
            }

            // --- Attempt to parse as an AccelTable resource ---
            try
            {
                // An accel table should be at least 6 bytes long (count, cp, type1 each 2 bytes).
                if (data.Length >= 6)
                {
                    // Peek at the initial bytes.
                    ushort count = BitConverter.ToUInt16(data, 0);
                    ushort cp = BitConverter.ToUInt16(data, 2);
                    ushort type1 = BitConverter.ToUInt16(data, 4);

                    // Heuristic for an accel table:
                    // - 'count' should be a reasonable number of accelerators (e.g., < 1000).
                    // - 'type1' should be a combination of known accelerator type flags (or 0 if no flags).
                    if (count < 1000 && (type1 == 0 || (type1 & (
                        RT_ACCELTABLE.KC_VIRTUALKEY | 
                        RT_ACCELTABLE.KC_SHIFT | 
                        RT_ACCELTABLE.KC_CTRL | 
                        RT_ACCELTABLE.KC_ALT)) != 0))
                    {
                        string result = RT_ACCELTABLE.Get(data, properties);
                        if (result != null) return result; // If parsing was successful, return the result
                    }
                }
            }
            catch (EndOfStreamException) { /* Continue to try other types */ }
            catch (Exception ex)
            {
                Console.WriteLine($"AccelTable parsing attempt failed: {ex.Message}");
            }

            // If none of the parsing attempts succeeded, return an error message.
            return "// Error: Could not determine resource type or parse data.";
        }
    }

}
